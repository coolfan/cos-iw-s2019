\documentclass[12pt, letterpaper]{article}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{cite}
\usepackage{url}
\usepackage{setspace}
\usepackage{fancyvrb}
\usepackage{ebproof}

\DefineVerbatimEnvironment
  {code}{Verbatim}
  {} 
  
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{invariant}[theorem]{Invariant}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{property}[theorem]{Property}
\newtheorem{proposition}[theorem]{Proposition}


\title{Comparing Proof Techniques on the Simply Typed Lambda Calculus between ITT and HoTT}
\author{Yanjun Yang, 2020\\Advisor: David Walker}
\date{\today}

\begin{document}
\doublespacing
\maketitle

%%-----------BEGIN WORK------------------------------------

\section{Extrinsically Typed $\lambda^{\to}$ with de Brujin Indices in ITT}
\begin{flushleft}
First, we worked with an extrinsically typed lambda calculus. In an extrinsically typed lambda calculus, the type of the lambda term exists separately from the lambda term itself. In this language, there are two types: a base type Boolean which contains normal forms are True and False, and a type-constructor $t\to t'$ whose normal forms are all well-typed lambda abstractions. There are additionally two other terms in the language, function application and variables, whose names are de Brujin indices. Contexts in this language are an ordered list of types of terms. The following is the language in Backus normal form.
\begin{align*}
\tau &::= \tau \to \tau\;|\text{ bool}\\
\Gamma &::= \varnothing\;|\;\Gamma, \tau\;\\
i_{\Gamma} &::= (n , \tau), \text{where } n \in [|\Gamma|] \text{ and } \Gamma[n] = \tau\\
e &::= \text{true } | \text{ false } | \; i_{\Gamma} \;| \;\lambda \tau.e \; | \; e
\;e\\
v &::= \text{true}\;|\;\text{false}\;|\;\lambda \tau . e
\end{align*}
The following are the typing rules of the language:
\[
\begin{prooftree}
\infer0[T-True]{\Gamma \vdash \text{true} : \text{bool}}	
\end{prooftree}
\;\;\;\;
\begin{prooftree}
\infer0[T-False]{\Gamma \vdash \text{false} : \text{bool}}
\end{prooftree}
\;\;\;\;
\begin{prooftree}
\hypo{n \in [|\Gamma|]}
\hypo{\Gamma[n] = \tau}
\infer2[T-Var]{\Gamma \vdash (n, \tau) : \tau}
\end{prooftree}
\]
\[
\begin{prooftree}
\hypo{\Gamma, \tau \vdash e : \tau'}
\infer1[T-Abs]{\Gamma \vdash \lambda \tau . e : \tau \to \tau'}
\end{prooftree}
\;\;\;\;
\begin{prooftree}
\hypo{\Gamma \vdash e_1 : \tau \to \tau'}
\hypo{\Gamma \vdash e_2 : \tau}
\infer2[T-App]{\Gamma \vdash e_1\;e_2 : \tau'}
\end{prooftree}
\]
The language uses call-by-value evaluation order. We use the notation $e \longrightarrow e'$ to denote that $e$ steps to $e'$ by using one of the evaluation rules. The following are the evaluation rules of the language
\[
\begin{prooftree}
\hypo{e_1 \longrightarrow e_1'}
\infer1[E-App1]{e_1\;e_2 \longrightarrow e_1'\;e_2}
\end{prooftree}
\;\;\;\;
\begin{prooftree}
\hypo{e_2 \longrightarrow e_2'}
\infer1[E-App2]{v_1\;e_2 \longrightarrow v_1\;e_2'}
\end{prooftree}
\;\;\;\;
\begin{prooftree}
\hypo{\Gamma \vdash \lambda \tau . e : \tau \to \tau'}
\hypo{\Gamma \vdash v : \tau}
\infer2[E-AppAbs]{(\lambda \tau . e)\;v \longrightarrow [v/(0, \tau)]e}
\end{prooftree}
\]
Note that the rule E-AppAbs requires that both the substitutand and substitute to be well-typed. With these definitions, we can now prove properties about the language.

\begin{theorem}
(Progress) For all expressions $e$ and types $\tau$, if $\varnothing \vdash e : \tau$, then either $e$ is a value or there exists an $e'$ such that $e \longrightarrow e'$
\end{theorem}
\begin{proof}
By induction on the structure of the typing derivation $\varnothing \vdash e : \tau$.
\end{proof}

\begin{lemma}
(Uniqueness of Types) For all contexts $\Gamma$, expressions $e$ and types $\tau, \tau'$, if $\Gamma \vdash e : \tau$ and $\Gamma \vdash e : \tau'$, then $\tau = \tau'$.
\begin{proof}
By induction on the structure of the expression $e$.
\end{proof}
\end{lemma}

\begin{definition}
For all contexts $\Gamma$ and variables $i_{\Gamma}$, let $\Gamma - i_{\Gamma}$ be the resulting context where $i_{\Gamma}$ is removed from $\Gamma$.
\end{definition}

\begin{lemma}
(Weakening) For all contexts $\Gamma$, variables $i_{\Gamma}$, expressions $e$ and types $\tau$, if $\Gamma - i_{\Gamma} \vdash e : \tau$, then $\Gamma \vdash e : \tau$.
\end{lemma}
\begin{proof}
By induction on the structure of $\Gamma - i_{\Gamma} \vdash e : \tau$
\end{proof}

\begin{lemma}
(Preservation of Types under Substitution) For all contexts $\Gamma$, variables $i_{\Gamma}$, expressions $e_1, e_2$, and types $\tau_1, \tau_2$, if $\Gamma \vdash i_{\Gamma} : \tau_1$, $\Gamma \vdash e_1 : \tau_2$, and $\Gamma - i_{\Gamma} \vdash e_2 : \tau_1$, then $\Gamma - i_{\Gamma} \vdash [e_2/i_{\Gamma}]e_1 : \tau_2$.
\end{lemma}
\begin{proof}
By induction on the structure of $\Gamma \vdash e_1 : \tau_2$, using the Weakening lemma for substituting into a function body.
\end{proof}

\begin{theorem}
(Preservation) For all expressions $e, e'$ and all types $\tau$, if $\varnothing \vdash e : \tau$ and $e \longrightarrow e'$, then $\varnothing \vdash e' : \tau$.
\end{theorem}
\begin{proof}
By induction on the structures of $\varnothing \vdash e : \tau$ and $e \longrightarrow e'$, using the Uniqueness of Types and Preservation of Types under Substitution lemmas for the E-AppAbs case.
\end{proof}
\end{flushleft}

\section{Intrinsically Typed $\lambda^{\to}$ with de Brujin Indices in ITT}

\begin{flushleft}
Next, we attempted the same proof, but using an intrinsically typed $\lambda^{\to}$. The key difference is that terms in the language are always tagged with their types. The following is the new BNF of the language:
\begin{align*}
\tau &::= \tau \to \tau\;|\text{ bool}\\
\Gamma &::= \varnothing\;|\;\Gamma, \tau\;\\
i^{\tau}_{\Gamma} &::= (n , \tau), \text{where } n \in [|\Gamma|] \text{ and } \Gamma[n] = \tau\\
e^{\tau} &::= \text{true}^{\text{bool}}\;|\;\text{false}^{\text{bool}}\;|\;i^{\tau}_{\Gamma}\;|\;(\lambda \tau.e^{\tau})^{\tau}\;|\;(e^{\tau} e^{\tau})^{\tau}\\
v &::= \text{true}^{\text{bool}}\;|\;\text{false}^{\text{bool}}\;|\;(\lambda \tau.e^{\tau})^{\tau}
\end{align*}
However, there are constraints on what the types of the expressions can be. Namely:
\[
\begin{prooftree}
\hypo{\tau}
\hypo{e^{\tau'}}
\infer2[]{(\lambda \tau . e^{\tau'})^{\tau \to \tau'}}
\end{prooftree}
\;\;\;\;
\begin{prooftree}
\hypo{e^{\tau \to \tau'}}
\hypo{e^{\tau}}
\infer2[]{(e^{\tau \to \tau'}\;e^{\tau})^{\tau'}}
\end{prooftree}
\]
With these constraints, typing an expression in this language becomes trivial: $e^{\tau} : \tau$. The execution rules are analogous to the ones for the extrinsically typed language, with the added constraint that expressions always evaluate to another expression of the same type. 

The proof of the Progress theorem is analogous to the extrinsically-typed case, but the proof of the Preservation theorem in the intrinsically typed case becomes trivial given how it is stated:

\begin{theorem}
(Preservation for intrinsically typed $\lambda^{\to}$) For all types $\tau$ and all expressions $e^{\tau}, e'^{\tau}$, if $e^{\tau} : \tau$ and $e^{\tau} \longrightarrow e'^{\tau}$, then $e'^{\tau} : \tau$.
\end{theorem}
\begin{proof}
By definition, $e'^{\tau} : \tau$.
\end{proof}
\end{flushleft}

\section{Extrinsically Typed $\lambda^{\to}$ with Names in ITT}
\begin{flushleft}
We now attempt the same proofs again, but this on a $\lambda^{\to}$ with named variables. The difference between this version of the $\lambda^{\to}$ and the ones above is that variable names, unlike de Brujin indices, need not be unique. Therefore, when a new variable that is introduced has the same name as another existing variable, the previous variable is shadowed and is no longer accessible. The following is the BNF for this language:
\begin{align*}
\tau &::= \tau \to \tau\;|\text{ bool}\\
\Gamma &::= \varnothing\;|\;\Gamma, x :\tau\;\\
e &::= \text{true } | \text{ false } | \; x \;| \;\lambda x:\tau.e \; | \; e
\;e\\
v &::= \text{true}\;|\;\text{false}\;|\;\lambda x : \tau . e
\end{align*}
The typing rules are the same as the above extrinsically-typed example, with the following modifications to reflect the fact that we are using named variables:
\[
\begin{prooftree}
\hypo{x:\tau \in \Gamma}
\infer1[T-Var]{\Gamma \vdash x : \tau}
\end{prooftree}
\;\;\;\;
\begin{prooftree}
\hypo{\Gamma, x : \tau \vdash e : \tau'}
\infer1[T-Abs]{\Gamma \vdash \lambda x : \tau . e : \tau \to \tau'}
\end{prooftree}
\]
Note that $x:\tau \in \Gamma$ means that $x:\tau$ is the most recent binding of the name $x$ with any type in $\Gamma$ (i.e. if $\Gamma = \varnothing, x:\tau', x:\tau$, then $x:\tau \in \Gamma$, but $x:\tau' \not\in \Gamma$).

By convention, substitution must be capture-avoiding, which means a substitution into the body of a lambda abstraction can only occur if the variable that is bound by that lambda abstraction is not in the free variables of the substituting expression (i.e. $[e_2/x](\lambda y : \tau . e_1) = \lambda y : \tau.([e_2/x]e_1)$ if and only if $y \not\in FV(e_2)$). Consequently, if a lambda abstraction binds a variable with the same name as the substituted variable, then the body of the lambda abstraction is unaffected(i.e. $[e_2/x](\lambda x : \tau . e_1) = \lambda x : \tau . e_1$), since the substituted variable is shadowed inside the body. However, since our language uses call-by-value execution order, we know that when we perform a substitution, the substituting term is always closed (i.e. it has no free variables). Therefore, we only need to check for variable shadowing when performing capture-avoiding substitution.

The proofs of type safety are the same except that they must be modified to accommodate the new definition of substitution. The proof of Progress is completely analogous, but the proof of Preservation requires additional lemmas:
\begin{definition}
(Sublist) For all contexts $\Gamma, \Delta$, $\Gamma$ is a sublist of $\Delta$ (written as $\Gamma \subseteq \Delta$) if and only if they satisfy the following inductive definition:
\begin{enumerate}[1.]
	\item For all contexts $\Delta$, $\varnothing \subseteq \Delta$.
	\item For all contexts $\Gamma, \Delta$, if $\Gamma \subseteq \Delta$, then for all variables $x$ and types $\tau$, $\Gamma, x:\tau \subseteq \Delta, x:\tau$.
\end{enumerate}
\end{definition}
\begin{lemma}
(Sublist Typing) For all contexts $\Gamma, \Delta$, expressions $e$ and types $\tau$, if $\Gamma \vdash e : \tau$ and $\Gamma \subseteq \Delta$, then $\Delta \vdash e : \tau$.
\end{lemma}
\begin{proof}
By induction on the structure of $\Gamma \vdash e : \tau$.
\end{proof}

\begin{lemma}
(Shadowing) For all context $\Gamma$, natural numbers $i, j$, expressions $e$ and types $\tau$, if $\Gamma \vdash e : \tau$ and the $i$-th variable of $\Gamma$ shadows the $j$-th variable of $\Gamma$, then $\Gamma - j \vdash e : \tau$.
\end{lemma}
\begin{proof}
By induction on the structure of $\Gamma \vdash e : \tau$.
\end{proof}

The proof of Preservation of Types under Substitution will follow the same structure as before, except that we will use the Sublist Typing lemma on the substituting expression (which is closed and therefore typed in context $\varnothing$) when replacing the substituted variable, and we will use the Shadowing lemma when substituting into a lambda abstraction that shadows the substituted variable. The proof of Preservation is unchanged.
\end{flushleft}
\bibliography{bib}
\bibliographystyle{unsrt}
\end{document}